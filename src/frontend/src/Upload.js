import { useState, useRef, useEffect } from "react";

import axios from "axios";

import fileDownload from 'js-file-download';

import { simpleKeyboardKeyNames } from './keyNames.js';
import FullKeyboard from './FullKeyboard.js';
import Keybinds from './Keybinds.js';
import Utils from './Utils.js';

axios.defaults.baseURL = 'http://localhost:8000';

const Upload = (props) => {
    const [changed, setChanged] = useState({});
    const [profileName, setProfileName] = useState(null);
    const [data, setData] = useState();
    const dataLoadedRef = useRef();
    const [highlighted, setHighlighted] = useState({});
    const [buffer, setBuffer] = useState({});
    const [settingKeybind, setSettingKeybind] = useState(false);
    
    const [filteringKey, setFilteringKey] = useState(null);
    const [foundRows, setFoundRows] = useState([]);
    const [filteringRows, setFilteringRows] = useState(false);
    
    const notifications = useRef(null);
    const cancel = useRef(null);
    const confirm = useRef(null);
    const keyboard = useRef(null);
    const highlightedGroup = useRef(null);
    
    useEffect(() => {
        // Initially set as disabled this way, otherwise if the buttons use an attribute
        // to be disabled then it just straight up doesn't work.
        if (cancel.current && confirm.current) {
            disableButtons(true);
        }
    }, []);
    
    useEffect(() => {
        if (!notifications.current) {
            notifications.current = props.notifications.current;
        }
    }, [props])
    
    useEffect(() => {
        if (data) {
            // Dear God please someone put me out of my misery
            dataLoadedRef.current = data;
        }
    }, [data]);
    
    const _handleSubmit = (event) => {
        // Prevent the browser from reloading the page
        event.preventDefault();
        
        const form = event.target;
        const formData = new FormData(form);
        
        // Check for changes and ask if they want to be overriden
        if (Object.keys(changed).length) {
            if (!window.confirm("You have changes made to the current hotkeys.  Loading from new files will erase all changes.")) {
                return;
            }
        }
        
        axios({
            method: 'post',
            url: '/upload/',
            data: formData,
        }).then((response) => {
            console.log(response.data);
            setChanged({});
            setData(response.data.data)
            setProfileName(response.data.name)
            setFilteringRows(false);
            setFoundRows([])
        }).catch((error) => {
            notifications.current.addNotification(error.response.data.message);
        });
    }
    
    const _getDefaultFiles = (event) => {
        event.preventDefault();
        
        // Check for changes and ask if they want to be overriden
        if (Object.keys(changed).length) {
            if (!window.confirm("You have changes made to the current hotkeys.  Loading the default hotkeys will erase all changes.")) {
                return;
            }
        }
        axios({
            method: 'get',
            url: '/upload/',
        }).then((response) => {
            console.log(response.data);
            setChanged({});
            setData(response.data);
            setProfileName(null);
            setFilteringRows(false);
            setFoundRows([])
        }).catch((error) => {
            notifications.current.addNotification(error.response.data.message);
        });
    }
    
    const uploadChanged = (event) => {
        event.preventDefault();
        axios({
            method: 'post',
            url: '/generate/',
            data: {changed: changed, profileName: profileName},
            responseType: 'blob',
        }).then((response) => {
            // todo: maybe make the filename generated by the server?
            fileDownload(response.data, "Hotkeys.zip");
        }).catch((error) => {
            notifications.current.addNotification(error.response.data.message);
        });
    }
    
    const confirmKeybinds = (newKeybinds, key) => {
        newKeybinds = JSON.parse(JSON.stringify(newKeybinds));
        clearHighlightedKeys(Utils.bufferToHighlights(newKeybinds, ["keybind-row-setting-button", "keybind-row-hover-button"]),
                                     true);
            
        // Update data and changed state variables
        let newHotkeys = {...data.hotkeys};
        let newChanged = {...changed};
        for (let [uuid,] of Object.entries(newKeybinds)) {
            // If key is provided, also update all keycodes
            if (key) {
                let keycode = Utils.findKeyByValue(simpleKeyboardKeyNames, key);
                newKeybinds[uuid].keycode = parseInt(keycode);
                newHotkeys[uuid].keycode = newKeybinds[uuid].keycode;
            }
            
            newHotkeys[uuid].ctrl = newKeybinds[uuid].ctrl;
            newHotkeys[uuid].shift = newKeybinds[uuid].shift;
            newHotkeys[uuid].alt = newKeybinds[uuid].alt;
            
            newChanged[uuid] = newKeybinds[uuid];
        }
        setData({groups: data.groups, hotkeys: {...newHotkeys}});
        setChanged(newChanged);
        
        setSettingKeybind(false);
        disableButtons(true);
        return {};
    }
    
    const handleSettingKeybind = (event) => {
        let dataset = Utils.getDatasetFromEvent(event);
        
        setBuffer((currentBuffer) => {
            let oldBuffer = JSON.parse(JSON.stringify(currentBuffer));
        
            // If already setting keybind, then add/remove from buffer based on the row's state
            if (settingKeybind) {
                if (oldBuffer.hasOwnProperty(dataset.id)) {
                    clearHighlightedKeys({
                        [dataset.id]: ["keybind-row-setting-button", "keybind-row-hover-button"]
                    }, true);
                    delete oldBuffer[dataset.id];
                }
                else {
                    oldBuffer[dataset.id] = dataset;
                    // Format to highlightedKeys style
                    setHighlightedKeys(
                        Utils.bufferToHighlights(oldBuffer, ["keybind-row-setting-button"]),
                                                 false);
                }
            }
            // First keybind selection, entering keybind change mode
            else {
                // todo: update when keyboard events are fixed, also add inverse
                // where exiting setting keybind state happens
                oldBuffer[dataset.id] = dataset;
                setHighlightedKeys(
                    Utils.bufferToHighlights(oldBuffer, ["keybind-row-setting-button"]),
                                             false);
                setSettingKeybind(true);
                disableButtons(false);
            }
            
            // If there's nothing in the buffer anymore, that means that there's no
            // active rows setting a keybind, so leave setting keybind state
            if (Object.keys(oldBuffer).length === 0) {
                setSettingKeybind(false);
                disableButtons(true);
            }
            return oldBuffer;
        });
    }
    
    const updateBuffer = (key) => {
        setBuffer((currentBuffer) => {
            let oldBuffer = JSON.parse(JSON.stringify(currentBuffer));
            // Is modifier key
            if (Object.keys(Utils.modifiers).includes(key)) {
                clearHighlightedKeys(Utils.bufferToHighlights(oldBuffer, ["keybind-row-setting-button", "keybind-row-hover-button"]),
                                     true);
                // Check to see what the state of the pressed modifier key is
                // If it's visisble then we need to set all to set all keys
                // in the buffer to false, and vice versa
                // Wish it wasn't two for loops
                let visible = false;
                for (let [uuid,] of Object.entries(oldBuffer)) {
                    if (oldBuffer[uuid][Utils.modifiers[key]]) {
                        visible = true;
                        break;
                    }
                }
                // Update modifier based on visibility
                for (let [uuid,] of Object.entries(oldBuffer)) {
                    oldBuffer[uuid][Utils.modifiers[key]] = !visible;
                }
                
                setHighlightedKeys(Utils.bufferToHighlights(oldBuffer, ["keybind-row-setting-button"]),
                                   false,
                                   oldBuffer);
            }
            // Not modifier key
            else {
                oldBuffer = confirmKeybinds(oldBuffer, key);
            }
            return oldBuffer;
        });
    }
    
    // Sets state of cancel/confirm buttons on keyboard
    const disableButtons = (state) => {
        confirm.current.disabled = state;
        cancel.current.disabled = state;
    }
    
    // Handles the actions of the cancel/confirm buttons
    const handleButtons = (event) => {
        if (settingKeybind) {
            if (event.target.value === "cancel") {
                clearHighlightedKeys(Utils.bufferToHighlights(buffer, ["keybind-row-setting-button", "keybind-row-hover-button"]),
                                     true);
                setSettingKeybind(false);
                setBuffer({});
            }
            else if (event.target.value === "confirm") {
                confirmKeybinds(buffer);
            }
            disableButtons(true);
        }
    }
    
    // If inputData is null, all highlighted keys will be cleared.
    // If inputData is provided, only the provided classes from the specified keys
    // will be cleared.
    // If useBuffer is true, then ONLY ONE KEY (UUID) must be provided.  This is
    // an unintuitive way of doing this but I'm just trying to get it to work.
    const clearHighlightedKeys = (inputData=null, useBuffer=false) => {
        setHighlighted((oldHighlighted) => {
            let current = JSON.parse(JSON.stringify(oldHighlighted))
            let transformed = {};
            let workingData = null;
            if (inputData) {
                workingData = inputData;
            }
            else {
                // No need to copy since workingData isn't mutated
                workingData = current
            }
            // Convert the data from: {uuid1: ["class1", "class2"], uuid2: ["class1", "class3"]}
            // to: {class1: ["uuid1", "uuid2"], class2: ["uuid1"], class3: ["uuid2"]}a
            // This makes it easier to pass the correct data to addButtonTheme/removeButtonTheme
            // on the keyboard instance
            for (let [uuid, classesArray] of Object.entries(workingData)) {
                classesArray.forEach((string) => {
                    // Create entry if it doesn't exist
                    if (!transformed[string]) {
                        transformed[string] = [];
                    }
                    transformed[string].push(uuid);
                });
                
                // Remove classes from UUID if it exists in the highlighted state
                if (Object.keys(current).includes(uuid)) {
                    current[uuid] = current[uuid].filter(x => !classesArray.includes(x));
                }
            }
            // Build the string to pass to the keyboard instance and call it
            for (let [cssClass, UUIDs] of Object.entries(transformed)) {
                let keysString = "";
                if (useBuffer) {
                    Object.keys(buffer).forEach((key) => {
                        keysString += Utils.datasetToKeyString(buffer[key]) + " ";
                    });
                }
                else {
                    UUIDs.forEach((UUID) => {
                        keysString += Utils.datasetToKeyString(data.hotkeys[UUID]) + " ";
                    });
                }
                
                keysString = keysString.trim()
                if (keysString !== "") {
                    keyboard.current.dispatch((instance) => {
                        instance.removeButtonTheme(keysString, cssClass);
                    });
                }
            }
            
            // Filter any UUIDs that no longer have classes applied
            current = Utils.objectFilter(current, ([,cssClasses]) => {
                return cssClasses.length;
            })
            // Finally update the currently highlighted
            return current;
        });
        
    }
    
    /*
        Used to set the CSS class of the keys that need to be highlighted.
        Used to highlight when hovering over a keybind, and when setting a keybind.
        data is an object with keys of UUID, and values of an array of CSS classes
    */
    const setHighlightedKeys = (inputData, clear=true, dataset=false) => {
        if (clear) {
            clearHighlightedKeys();
        }
        
        setHighlighted((oldHighlighted) => {
            let current = JSON.parse(JSON.stringify(oldHighlighted))
            let transformed = {};
            // Iterate over each entry in the input object
            for (let [uuid, classesArray] of Object.entries(inputData)) {
                classesArray.forEach((string) => {
                    // Initialize an array if the string key doesn't exist yet
                    if (!transformed[string]) {
                        transformed[string] = [];
                    }
                    // Add the UUID to the array corresponding to the string
                    transformed[string].push(uuid);
                });
                
                // Also update highlighted if we didn't clear so we only iterate once
                if (!clear) {
                    if (Object.keys(current).includes(uuid)) {
                        current[uuid] = [...new Set([...classesArray, ...current[uuid]])]
                    }
                    else {
                        current[uuid] = [...classesArray];
                    }
                }
            }
            
            // Normally the dataset used to determine which keys to to highlight comes
            // from the main hotkeys data.  However, when setting a new hotkey, that data
            // isn't updated until the hotkey is finalized.  As such, when setting a new hotkey
            // for the changing hotkey specifically, we need to create the key string from
            // the most up-to-date source: the buffer state
            for (let [cssClass, UUIDs] of Object.entries(transformed)) {
                let keysString = "";
                if (dataset) {
                    Object.keys(dataset).forEach((key) => {
                        if (Object.keys(inputData).includes(key)) {
                             keysString += Utils.datasetToKeyString(dataset[key]) + " ";
                        }
                    });
                }
                else {
                    UUIDs.forEach((UUID) => {
                        keysString += Utils.datasetToKeyString(data.hotkeys[UUID]) + " ";
                    });
                }
                
                keysString = keysString.trim()
                if (keysString !== "") {
                    keyboard.current.dispatch((instance) => {
                        instance.addButtonTheme(keysString, cssClass);
                    });
                }
            }
            if (clear) {
                return inputData;
            }
            else {
                return current;
            }
        });
    }

    /*
        Passed to Keybinds to be used as a callback for updating the keyboard highlighting
    */
    const updateCurrentHover = (event) => {
        let dataset = Utils.getDatasetFromEvent(event);
        if (event.type === "mouseover") {
            let keys = {};
            if (dataset) {
                keys[dataset.id] = ["keybind-row-hover-button"]
            }
            setHighlightedKeys(keys, false);
        }
        else if (event.type === "mouseout") {
            // We have to explicitly say to remove this key, otherwise
            // when the mouse moves across multiple elements in the same render
            // cycle the state isn't accurate to what highlights need to be removed
            // in clearHighlightedKeys()
            clearHighlightedKeys({
                [dataset.id]: ["keybind-row-hover-button"]
            });
        }
    }
    
    /*
        Given a keycode, returns an array of all UUIDs that have that keycode as their
        current key
    */
    const findRowsByKeycode = (keycode) => {
        if (dataLoadedRef.current) {
           let foundRows = [];
            if (keycode) {
                foundRows = Object.entries(dataLoadedRef.current.hotkeys)
                    .filter(([k, v]) => dataLoadedRef.current.hotkeys[k].keycode === keycode)
                    .map(([k]) => k);
            }
            setFoundRows(foundRows);
        }
    }
    
    const toggleFilteringRows = (key) => {
        let keycode = parseInt(Utils.findKeyByValue(simpleKeyboardKeyNames, key));
        
        // If there's currently a filteringKey set and the user clicked
        // on the currently stored key
        if (!filteringKey) {
            setFilteringRows(true);
            setFilteringKey(keycode);
            
            // Highlight currently key being filtered
            keyboard.current.dispatch((instance) => {
                instance.addButtonTheme(key, "button-hover-filtering-button");
            });
        }
        else if (filteringKey && keycode === filteringKey) {
            setFilteringKey(null);
            setFilteringRows(false);
            keyboard.current.dispatch((instance) => {
                instance.removeButtonTheme(key, "button-hover-filtering-button");
            });
        }
    }
    
    const selectMenu = (event) => {
        if (!highlightedGroup.current) {
            let rows = {}
            data.groups[event.target.textContent].forEach((UUID) => {
                rows[UUID] = ["menu-group-select-button"];
            });
            setHighlightedKeys(rows, false);
            
            highlightedGroup.current = event.target;
        }
        
        else if (event.target.textContent === highlightedGroup?.current?.textContent) {
            let rows = {}
            data.groups[event.target.textContent].forEach((UUID) => {
                rows[UUID] = ["menu-group-select-button"];
            });
            clearHighlightedKeys(rows);
            
            highlightedGroup.current = null;
        }
    }
    
    const hoverMenu = (event) => {
        if (event.type === "mouseover") {
            let rows = {}
            data.groups[event.target.textContent].forEach((UUID) => {
                rows[UUID] = ["menu-group-hover-button"];
            });
            setHighlightedKeys(rows, false);
        }
        else if (event.type === "mouseout") {
            let rows = {}
            data.groups[event.target.textContent].forEach((UUID) => {
                rows[UUID] = ["menu-group-hover-button"];
            });
            clearHighlightedKeys(rows);
        }
    }
    
    return (
        <>
        <div id="controls">
            <div id="upload">
                <h4>Edit Custom Hotkeys</h4>
                <form method="POST" onSubmit={_handleSubmit}>
                    <input
                        type="file"
                        name="files"
                        multiple
                    />
                    <button type="submit" className="confirm">Upload</button>
                </form>
            </div>
            
            <div id="get-changes">
                <button onClick={uploadChanged} className="confirm">Download Changes</button>
            </div>
            
            <div id="load-defaults">
                <form method="POST" onSubmit={_getDefaultFiles}>
                    <button type="submit">Load Default Hotkeys</button>
                </form>
            </div>
        </div>
        
        <div id="keyboard-wrapper">
             {/*className={settingKeybind ? "" : "disable-keyboard"}>*/}
            <FullKeyboard ref={keyboard}
                          updateBuffer={updateBuffer}
                          settingKeybind={settingKeybind}
                          findRowsByKeycode={findRowsByKeycode}
                          toggleFilteringRows={toggleFilteringRows}
                          filteringRows={filteringRows} />
            <div id="confirmCancelWrapper">
                <button ref={cancel}
                        id="cancel"
                        className="cancel"
                        value="cancel"
                        onClick={(e) => handleButtons(e)}>
                    Cancel
                </button>
                <button ref={confirm}
                        id="confirm"
                        className="confirm"
                        value="confirm"
                        onClick={(e) => handleButtons(e)}>
                    Confirm
                </button>
            </div>
        </div>
        
        <Keybinds data={data}
                  buffer={buffer}
                  updateCurrentHover={updateCurrentHover}
                  handleSettingKeybind={handleSettingKeybind}
                  foundRows={foundRows}
                  filteringRows={filteringRows}
                  selectMenu={selectMenu}
                  hoverMenu={hoverMenu}
                  highlighted={highlighted} />
        </>
    );
};

export default Upload;